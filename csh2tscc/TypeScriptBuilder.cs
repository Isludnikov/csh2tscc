using System.Reflection;
using System.Text.Json.Serialization;

namespace csh2tscc;

internal class TypeScriptBuilder(TypesGeneratorParameters parameters, TypeResolver resolver, TypeDiscovery discovery)
{
    private record AttributeProcessingResult(string Name, bool IsBlocked);

    private static readonly string? Title = typeof(TypeScriptBuilder).Assembly.GetCustomAttribute<AssemblyTitleAttribute>()?.Title;
    private static readonly string? Version = typeof(TypeScriptBuilder).Assembly.GetName().Version?.ToString();
    internal string BuildFileFromType(Type typeToWrite)
    {
        var sb = new StringBuilderCustom(parameters.Verbose);
        sb.AppendDebugLine("Debug mode");
        sb.AppendDebugLine($"{Title} v{Version}");
        sb.AppendLine(TypeScriptConstants.AutoGeneratedHeader);
        sb.AppendLine();
        sb = typeToWrite.IsEnum ? BuildFromEnum(typeToWrite, sb) : BuildFromClass(typeToWrite, sb);
        return sb.ToString();
    }

    private StringBuilderCustom BuildFromEnum(Type typeToWrite, StringBuilderCustom sb)
    {
        sb.AppendLine($"{TypeScriptConstants.ExportEnum} {TypeNameHelper.GetTypeScriptName(typeToWrite, parameters.UseFullNames)} {{");
        var fields = typeToWrite.GetFields(BindingFlags.Static | BindingFlags.Public);
        foreach (var field in fields)
        {
            sb.AppendDebugLine($"Default field name [{field.Name}]");
            var attributes = field.GetCustomAttributes().ToList();
            var result = ProcessMemberAttributes(attributes, field.Name, typeToWrite, sb);

            if (result.IsBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{field.Name}] is blocked");
                continue;
            }

            sb.AppendLine($"  {field.Name} = '{result.Name}',");
        }

        sb.AppendLine('}');
        return sb;
    }

    private StringBuilderCustom BuildFromClass(Type typeToWrite, StringBuilderCustom sb)
    {
        var affected = discovery.ListAffectedTypes(typeToWrite).ToList();
        var genericParameters = typeToWrite.IsGenericType ? typeToWrite.GetGenericArguments() : [];
        var genericHeader = genericParameters.Length == 0
            ? string.Empty
            : $"{TypeScriptConstants.GenericOpen}{string.Join(",", genericParameters.Select(x => x.Name))}{TypeScriptConstants.GenericClose}";
        var importsAdded = false;
        foreach (var affType in affected)
        {
            if (affType == typeToWrite)
            {
                continue;
            }

            sb.AppendLine(string.Format(TypeScriptConstants.ImportFormat, TypeNameHelper.NormalizeClassName(TypeNameHelper.GetTypeScriptName(affType, parameters.UseFullNames))));
            importsAdded = true;
        }

        if (importsAdded)
        {
            sb.AppendLine();
        }

        sb.AppendLine($"{TypeScriptConstants.ExportInterface} {TypeNameHelper.NormalizeClassName(TypeNameHelper.GetTypeScriptName(typeToWrite, parameters.UseFullNames))}{genericHeader} {{");

        var properties = typeToWrite.GetProperties();

        foreach (var property in properties)
        {
            var defaultName = GetClassPropertyNameToWrite(property.Name);
            sb.AppendDebugLine($"Default field name [{defaultName}]");
            var attributes = property.GetCustomAttributes().ToList();
            var result = ProcessMemberAttributes(attributes, defaultName, typeToWrite, sb, throwOnNullName: true);

            if (result.IsBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{property.Name}] is blocked");
                continue;
            }

            var isNullableByDefinition = IsNullableHelper.IsNullable(typeToWrite, property);
            if (isNullableByDefinition)
            {
                sb.AppendDebugLine("Property is nullable by definition");
            }

            var hasNotNullableAttribute = CommonHelper.HasNonNullableAttribute(property);
            if (hasNotNullableAttribute)
            {
                sb.AppendDebugLine("Property has non-nullable attribute");
            }

            var isNullable = isNullableByDefinition && !hasNotNullableAttribute;
            var context = new PropertyTypeExtractionContext
            {
                ClassToWrite = typeToWrite,
                PropInfo = property,
                PropertyType = property.PropertyType,
                AffectedTypes = affected,
                GenericTypes = genericParameters,
                SuppressNullable = hasNotNullableAttribute,
                BooleanContainer = null,
                IsNullable = isNullable
            };
            sb.AppendLine($"  {result.Name}{(isNullable ? "?" : string.Empty)}: {resolver.ResolveTypeToTypeScript(context)};");
        }

        sb.AppendLine('}');
        return sb;
    }

    private AttributeProcessingResult ProcessMemberAttributes(
        IList<Attribute> attributes,
        string defaultName,
        Type parentType,
        StringBuilderCustom sb,
        bool throwOnNullName = false)
    {
        var name = defaultName;
        var nameAttributeCount = 0;
        var isBlocked = false;

        foreach (var attribute in attributes)
        {
            var attributeType = attribute.GetType();

            // Check for serialization naming attributes
            if (parameters.SerializationNamingAttributes.TryGetValue(attributeType.Name, out var attributePropertyName))
            {
                ++nameAttributeCount;
                var prop = attributeType.GetProperty(attributePropertyName)
                    ?? throw new AttributeProcessingException(
                        $"No property name [{attributePropertyName}] for type [{attributeType.Name}]",
                        attributeType.Name);

                var extractedName = prop.GetValue(attribute, null)?.ToString();
                if (extractedName == null && throwOnNullName)
                {
                    throw new AttributeProcessingException(
                        $"Property name [{attributePropertyName}] for type [{attributeType.Name}] is null",
                        attributeType.Name);
                }

                name = extractedName ?? name;
                sb.AppendDebugLine($"New field name is [{name}] from attribute [{attributePropertyName}]");
            }

            // Check for no-serialization attributes
            var attributeFromNoSerializingList = parameters.NoSerializationAttributes.SingleOrDefault(x => x == attributeType.Name);
            switch (attributeFromNoSerializingList)
            {
                case null:
                    continue;
                case nameof(JsonIgnoreAttribute)
                    when (attributeType.FullName?.StartsWith(WellKnownNames.SystemTextJsonNamespace) ?? false):
                    {
                        var jic = (JsonIgnoreCondition)attributeType.GetProperty("Condition")!.GetValue(attribute, null)!;
                        sb.AppendDebugLine($"Found attribute [{attributeType.Name}] condition is [{jic}]");
                        if (jic == JsonIgnoreCondition.Always)
                        {
                            isBlocked = true;
                        }
                        break;
                    }
                default:
                    sb.AppendDebugLine($"Found attribute [{attributeType.Name}]");
                    isBlocked = true;
                    break;
            }
        }

        if (nameAttributeCount > 1)
        {
            throw new InvalidSerializationConfigException(
                $"Property name [{name}] of type [{parentType}] has more than one serialization naming attribute");
        }

        return new AttributeProcessingResult(name, isBlocked);
    }

    private string GetClassPropertyNameToWrite(string s) => parameters.CamelCaseProperties ? char.ToLowerInvariant(s[0]) + s[1..] : s;
}
