using System.Collections.Frozen;
using System.Data;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace csh2tscc;

public class TypesGenerator(TypesGeneratorParameters parameters)
{
    private static readonly Type[] NumberTypes = [
        typeof(int), typeof(uint), typeof(short), typeof(byte), typeof(sbyte), typeof(long), typeof(ulong),
        typeof(float), typeof(double), typeof(ushort), typeof(decimal),
    ];

    private static readonly FrozenSet<string> PreventNullAttributes = ["System.ComponentModel.DataAnnotations.RequiredAttribute", "System.Diagnostics.CodeAnalysis.NotNullAttribute"];
    private static readonly Type[] ToStringTypes = [
        typeof(Guid), typeof(DateTime), typeof(Uri), typeof(TimeSpan)
    ];
    public TypesGeneratorParameters Config => parameters;

    public Dictionary<string, string> TransformTypes() => GetTypes().ToDictionary(typeToWrite => NormalizeClassName(GetTypeName(typeToWrite)) + ".tsx", BuildFileFromType);

    private static string NormalizeClassName(string argName) => argName.Contains('`') ? argName.Remove(argName.LastIndexOf('`')) : argName;

    private string BuildFileFromType(Type typeToWrite)
    {
        var sb = new StringBuilderCustom(parameters.Verbose);
        sb.AppendDebugLine("Debug mode");
        sb.AppendLine("//This file is AUTOGENERATED!!! All manual changes will be lost after regeneration.");
        sb.AppendLine();
        return typeToWrite.IsEnum ? BuildFromEnum(typeToWrite, sb) : BuildFromClass(typeToWrite, sb);
    }

    private string BuildFromEnum(Type typeToWrite, StringBuilderCustom sb)
    {
        sb.AppendLine($"export enum {GetTypeName(typeToWrite)} {{");
        var fields = typeToWrite.GetFields(BindingFlags.Static | BindingFlags.Public);
        foreach (var field in fields)
        {
            var value = field.Name;
            sb.AppendDebugLine($"Default field name [{value}]");
            var attributes = field.GetCustomAttributes().ToList();
            var nameAttributeCount = 0;
            var isBlocked = false;
            foreach (var attribute in attributes)
            {
                var attributeType = attribute.GetType();
                var attributeFromNamingDictionaryExists = parameters.SerializationNamingAttributes.TryGetValue(attributeType.Name, out var attributeNameFromNamingDictionary);
                if (attributeFromNamingDictionaryExists)
                {
                    ++nameAttributeCount;
                    var prop = attributeType.GetProperty(attributeNameFromNamingDictionary) ?? throw new InvalidDataContractException($"No property name [{attributeNameFromNamingDictionary}] for type [{attributeType.Name}]");
                    value = prop.GetValue(attribute, null)?.ToString();
                    sb.AppendDebugLine($"New field name is [{value}] from attribute [{attributeNameFromNamingDictionary}]");
                }

                var attributeFromNoSerializingList = parameters.NoSerializationAttributes.SingleOrDefault(x => x == attributeType.Name);
                switch (attributeFromNoSerializingList)
                {
                    case null:
                        continue;
                    case nameof(JsonIgnoreAttribute)
                        when (attribute.GetType().FullName?.StartsWith("System.Text.Json") ?? false):
                        {
                            var jic = (JsonIgnoreCondition)attribute.GetType().GetProperty("Condition").GetValue(attribute, null);
                            sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}] condition is [{jic.ToString()}]");
                            if (jic == JsonIgnoreCondition.Always) isBlocked = true;
                            break;
                        }
                    default:
                        sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}]");
                        isBlocked = true;
                        break;
                }
            }

            if (nameAttributeCount > 1)
                throw new InvalidDataException($"Property name [{value}] of type [{typeToWrite}] has more than one serialization naming attribute");
            if (isBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{field.Name}] is blocked");
                continue;
            }

            sb.AppendLine($"  {field.Name} = '{value}',");
        }

        sb.Append('}');
        return sb.ToString();
    }

    private string BuildFromClass(Type typeToWrite, StringBuilderCustom sb)
    {
        var affected = ListAffectedTypes(typeToWrite).ToList();
        var genericParameters = typeToWrite.IsGenericType ? typeToWrite.GetGenericArguments() : [];
        var genericHeader = genericParameters.Length == 0 ? string.Empty : "<" + string.Join(",", genericParameters.Select(x => x.Name)) + ">";
        var importsAdded = false;
        foreach (var affType in affected)
        {
            if (affType == typeToWrite) continue;
            sb.AppendLine($"import {{ {NormalizeClassName(GetTypeName(affType))} }} from \"./{NormalizeClassName(GetTypeName(affType))}\";");
            importsAdded = true;
        }

        if (importsAdded) sb.AppendLine();
        sb.AppendLine($"export interface {NormalizeClassName(GetTypeName(typeToWrite))}{genericHeader} {{");

        var properties = typeToWrite.GetProperties();

        foreach (var property in properties)
        {
            var value = GetClassPropertyNameToWrite(property.Name);
            sb.AppendDebugLine($"Default field name [{value}]");
            var attributes = property.GetCustomAttributes().ToList();
            var nameAttributeCount = 0;
            var isBlocked = false;
            foreach (var attribute in attributes)
            {
                var attributeType = attribute.GetType();
                var attributeFromNamingDictionaryExists = parameters.SerializationNamingAttributes.TryGetValue(attributeType.Name, out var attributeNameFromNamingDictionary);
                if (attributeFromNamingDictionaryExists)
                {
                    ++nameAttributeCount;
                    var prop = attributeType.GetProperty(attributeNameFromNamingDictionary) ?? throw new InvalidDataContractException($"No property name [{attributeNameFromNamingDictionary}] for type [{attributeType.Name}]");
                    value = prop.GetValue(attribute, null)?.ToString() ?? throw new InvalidDataContractException($"Property name [{attributeNameFromNamingDictionary}] for type [{attributeType.Name}] is null");
                    sb.AppendDebugLine($"New field name is [{value}] from attribute [{attributeNameFromNamingDictionary}]");
                }

                var attributeFromNoSerializingList = parameters.NoSerializationAttributes.SingleOrDefault(x => x == attributeType.Name);
                switch (attributeFromNoSerializingList)
                {
                    case null:
                        continue;
                    case nameof(JsonIgnoreAttribute):
                        {
                            var jic = (JsonIgnoreCondition)attribute.GetType().GetProperty("Condition").GetValue(attribute, null);
                            sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}] condition is [{jic.ToString()}]");
                            if (jic == JsonIgnoreCondition.Always) isBlocked = true;
                            break;
                        }
                    default:
                        isBlocked = true;
                        sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}]");
                        break;
                }
            }

            if (nameAttributeCount > 1) throw new InvalidDataException($"Property name [{value}] of type [{typeToWrite}] has more than one serialization naming attribute");
            if (isBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{property.Name}] is blocked");
                continue;
            }

            var isNullableByDefinition = IsNullableHelper.IsNullable(typeToWrite, property);
            if (isNullableByDefinition) sb.AppendDebugLine("Property is nullable by definition");
            var hasNotNullableAttribute = HasNonNullableAttribute(property);
            if (hasNotNullableAttribute) sb.AppendDebugLine("Property has non-nullable attribute");
            var isNullable = isNullableByDefinition && !hasNotNullableAttribute;
            sb.AppendLine($"  {value}{(isNullable ? "?" : string.Empty)}: {GetPropertyTypeTypescript(typeToWrite, property, property.PropertyType, affected, genericParameters, isNullable, hasNotNullableAttribute)};");
        }

        sb.Append('}');
        return sb.ToString();
    }

    private static bool HasNonNullableAttribute(PropertyInfo property)
    {
        var preventAttributeExists =
            property.GetCustomAttributes().Any(x => PreventNullAttributes.Contains(x.GetType().FullName ?? string.Empty));
        if (preventAttributeExists) return true;
        var getMethod = property.GetGetMethod();
        if (getMethod == null) return false;
        var returnParameter = getMethod.ReturnParameter;
        return returnParameter.GetCustomAttributes().Any(x => PreventNullAttributes.Contains(x.GetType().FullName ?? string.Empty));
    }

    private string GetTypeName(Type type) => (parameters.UseFullNames ? type.FullName ?? type.Name : type.Name).Replace('.', '_');

    private string GetPropertyTypeTypescript(Type classToWrite, PropertyInfo? propInfo, Type propertyType, IEnumerable<Type> affectedTypes, IEnumerable<Type> genericTypes, bool isNullable, bool suppressNullable = false)
    {
        var nullable = propInfo != null ? IsNullableHelper.IsNullable(classToWrite, propInfo) : isNullable;
        if (suppressNullable) nullable = false;
        var checkedType = Nullable.GetUnderlyingType(propertyType);
        if (checkedType != null) propertyType = checkedType;
        if (parameters.CustomMap.TryGetValue(propertyType.Name, out var value))
            return value + (nullable ? " | null" : string.Empty);
        if (!string.IsNullOrWhiteSpace(propertyType.FullName) &&
            parameters.CustomMap.TryGetValue(propertyType.FullName, out var value1))
            return value1 + (nullable ? " | null" : string.Empty);
        if (NumberTypes.Contains(propertyType)) return "number" + (nullable ? " | null" : string.Empty);
        if (propertyType == typeof(bool)) return "boolean" + (nullable ? " | null" : string.Empty);
        if (propertyType.IsEnum) return GetTypeName(propertyType) + (nullable ? " | null" : string.Empty);
        if (propertyType == typeof(string)) return "string" + (nullable ? " | null" : string.Empty);
        if (propertyType == typeof(object)) return "unknown";
        var nullableList = propInfo == null ? [] : IsNullableHelper.IsNullableArray(classToWrite, propInfo);
        if (propertyType.IsArray)
            return GetPropertyTypeTypescript(classToWrite, null, propertyType.GetElementType()!, affectedTypes, genericTypes, nullableList.Count > 1 ? nullableList[1] : isNullable) + "[]" + (nullable ? " | null" : string.Empty);
        if (propertyType.InstanceOfGenericInterface(typeof(IDictionary<,>)))
        {
            var genericArguments = propertyType.GetInterfaces().SingleOrDefault(x => x.InstanceOfGenericInterface(typeof(IDictionary<,>)))?.GetGenericArguments() ?? propertyType.GetGenericArguments();
            var enumerator = 1;
            return $"Map<{GetPropertyTypeTypescript(classToWrite, null, genericArguments[0], affectedTypes, genericTypes, genericArguments[0].IsValueType ? IsNullableHelper.IsValueTypeNullable(genericArguments[0]) : SelectNullable(nullableList, enumerator++, nullable))}, {GetPropertyTypeTypescript(classToWrite, null, genericArguments[1], affectedTypes, genericTypes, genericArguments[1].IsValueType ? IsNullableHelper.IsValueTypeNullable(genericArguments[1]) : SelectNullable(nullableList, enumerator++, nullable))}>" + (nullable ? " | null" : string.Empty);
        }

        if (propertyType.InstanceOfGenericInterface(typeof(IEnumerable<>)))
        {
            var genericArguments = propertyType.GetGenericArguments();
            return $"{GetPropertyTypeTypescript(classToWrite, null, genericArguments[0], affectedTypes, genericTypes, genericArguments[0].IsValueType ? IsNullableHelper.IsValueTypeNullable(genericArguments[0]) : SelectNullable(nullableList, 1, nullable))}[]" + (nullable ? " | null" : string.Empty);
        }

        if (ToStringTypes.Contains(propertyType)) return "string" + (nullable ? " | null" : string.Empty);
        if (propertyType.IsGenericType)
        {
            var localGenericArguments = propertyType.GetGenericArguments().Take(GenericHelper.LocalGenericParameterCount(propertyType)).ToArray();
            var enumerator = 1;
            return NormalizeClassName(GetTypeName(propertyType)) + "<" + localGenericArguments.Select((x, j) => GetPropertyTypeTypescript(classToWrite, null, x, affectedTypes, genericTypes, x.IsValueType ? IsNullableHelper.IsValueTypeNullable(x) : SelectNullable(nullableList, enumerator++, nullable))).Aggregate((i, j) => i + ", " + j) + ">" + (nullable ? " | null" : string.Empty);
        }

        if (affectedTypes.Any(x => x.FullName == propertyType.FullName) || genericTypes.Any(x => x.Name == propertyType.Name))
            return NormalizeClassName(GetTypeName(propertyType)) + (nullable ? " | null" : string.Empty);
        throw new InvalidExpressionException($"Unsupported type [{propertyType.FullName}]");
    }

    private static bool SelectNullable(List<bool> list, int enumerator, bool defaultValue) => list.Count <= enumerator ? defaultValue : list[enumerator];

    private List<Type> ListAffectedTypes(Type type)
    {
        var affected = new List<Type>();
        if (type.IsGenericType) AddType(affected, type.GenericTypeArguments);
        var props = type.GetProperties();
        foreach (var prop in props)
        {
            if (prop.PropertyType.IsGenericType) AddType(affected, prop.PropertyType.GenericTypeArguments);
            AddType(affected, [prop.PropertyType]);
        }

        RemoveTypes(affected);
        return affected;
    }

    private void AddType(List<Type> list, Type[] types)
    {
        foreach (var type in types)
        {
            if (parameters.CustomMap.ContainsKey(type.Name) || (!string.IsNullOrWhiteSpace(type.FullName) && parameters.CustomMap.ContainsKey(type.FullName)))
                continue;
            if (type.IsGenericType)
                AddType(list, type.GenericTypeArguments);
            if (type.IsArray)
                AddType(list, [type.GetElementType()!]);
            else if (type.FullName != null && StartsWith(type.FullName) && list.All(x => NormalizeClassName(x.FullName ?? x.Name) != NormalizeClassName(type.FullName ?? type.Name)))
                list.Add(type);
        }
    }

    private List<Type> GetTypes()
    {
        var types = new List<Type>();
        var filePaths = parameters.LibraryFileNames.Select(x => Path.GetDirectoryName(Path.GetFullPath(x))).ToList();
        foreach (var param in parameters.LibraryFileNames)
        {
            var exactPath = Path.GetFullPath(param);
            var context = new CustomAssemblyLoadContext(filePaths);
            var assembly = context.LoadAssembly(exactPath);
            types.AddRange(assembly.GetExportedTypes().Where(t => StartsWith(t.FullName) && !t.Name.StartsWith('<')));
        }

        return types;
    }

    private int RemoveTypes(List<Type> types)
    {
        var result = 0;
        result += types.RemoveAll(t => parameters.CustomMap.Keys.Contains(t.Name));
        result += types.RemoveAll(t => !string.IsNullOrWhiteSpace(t.FullName) && parameters.CustomMap.Keys.Contains(t.FullName));
        result += types.RemoveAll(t => !string.IsNullOrWhiteSpace(t.FullName) && parameters.RootNamespacesExcluded.Any(x => t.FullName.Contains(x)));
        result += types.RemoveAll(t => t.GetInterfaces().Any(i => i.InstanceOfGenericType(typeof(IDictionary<,>))));
        result += types.RemoveAll(t => t.GetInterfaces().Any(i => i.InstanceOfGenericType(typeof(IEnumerable<>))));
        return result;
    }

    private string GetClassPropertyNameToWrite(string s) => parameters.CamelCaseProperties ? char.ToLowerInvariant(s[0]) + s[1..] : s;

    private bool StartsWith(string needle) => parameters.RootNamespaces.Any(needle.StartsWith);

}