using System.Reflection;
using System.Text.Json.Serialization;

namespace csh2tscc;

public class TypesGenerator(TypesGeneratorParameters parameters)
{
    public static TypesGenerator Create(TypesGeneratorParameters parameters) => new(parameters);

    private static readonly Type[] NumberTypes = [
        typeof(int), typeof(uint), typeof(short), typeof(byte), typeof(sbyte), typeof(long), typeof(ulong),
        typeof(float), typeof(double), typeof(ushort), typeof(decimal)
    ];


    private static readonly Type[] ToStringTypes = [
        typeof(Guid), typeof(DateTime), typeof(Uri), typeof(TimeSpan)
    ];
    public TypesGeneratorParameters Config => parameters;

    private record AttributeProcessingResult(string Name, bool IsBlocked);

    private AttributeProcessingResult ProcessMemberAttributes(
        IList<Attribute> attributes,
        string defaultName,
        Type parentType,
        StringBuilderCustom sb,
        bool throwOnNullName = false)
    {
        var name = defaultName;
        var nameAttributeCount = 0;
        var isBlocked = false;

        foreach (var attribute in attributes)
        {
            var attributeType = attribute.GetType();

            // Check for serialization naming attributes
            if (parameters.SerializationNamingAttributes.TryGetValue(attributeType.Name, out var attributePropertyName))
            {
                ++nameAttributeCount;
                var prop = attributeType.GetProperty(attributePropertyName)
                    ?? throw new AttributeProcessingException(
                        $"No property name [{attributePropertyName}] for type [{attributeType.Name}]",
                        attributeType.Name);

                var extractedName = prop.GetValue(attribute, null)?.ToString();
                if (extractedName == null && throwOnNullName)
                {
                    throw new AttributeProcessingException(
                        $"Property name [{attributePropertyName}] for type [{attributeType.Name}] is null",
                        attributeType.Name);
                }

                name = extractedName ?? name;
                sb.AppendDebugLine($"New field name is [{name}] from attribute [{attributePropertyName}]");
            }

            // Check for no-serialization attributes
            var attributeFromNoSerializingList = parameters.NoSerializationAttributes.SingleOrDefault(x => x == attributeType.Name);
            switch (attributeFromNoSerializingList)
            {
                case null:
                    continue;
                case nameof(JsonIgnoreAttribute)
                    when (attributeType.FullName?.StartsWith(WellKnownNames.SystemTextJsonNamespace) ?? false):
                    {
                        var jic = (JsonIgnoreCondition)attributeType.GetProperty("Condition")!.GetValue(attribute, null)!;
                        sb.AppendDebugLine($"Found attribute [{attributeType.Name}] condition is [{jic}]");
                        if (jic == JsonIgnoreCondition.Always)
                        {
                            isBlocked = true;
                        }
                        break;
                    }
                default:
                    sb.AppendDebugLine($"Found attribute [{attributeType.Name}]");
                    isBlocked = true;
                    break;
            }
        }

        if (nameAttributeCount > 1)
        {
            throw new InvalidSerializationConfigException(
                $"Property name [{name}] of type [{parentType}] has more than one serialization naming attribute");
        }

        return new AttributeProcessingResult(name, isBlocked);
    }

    public Dictionary<string, string> TransformTypes() => GetTypes().ToDictionary(typeToWrite => NormalizeClassName(GetTypeScriptName(typeToWrite)) + ".tsx", BuildFileFromType);

    private static string NormalizeClassName(string className) => className.Contains(TypeScriptConstants.GenericAritySeparator)
        ? className[..className.LastIndexOf(TypeScriptConstants.GenericAritySeparator)]
        : className;

    internal string BuildFileFromType(Type typeToWrite)
    {
        var sb = new StringBuilderCustom(parameters.Verbose);
        sb.AppendDebugLine("Debug mode");
        sb.AppendLine(TypeScriptConstants.AutoGeneratedHeader);
        sb.AppendLine();
        sb = typeToWrite.IsEnum ? BuildFromEnum(typeToWrite, sb) : BuildFromClass(typeToWrite, sb);
        sb.AppendDebugLine($"// {TypeScriptConstants.Name} {TypeScriptConstants.Version}");
        return sb.ToString();
    }

    private StringBuilderCustom BuildFromEnum(Type typeToWrite, StringBuilderCustom sb)
    {
        sb.AppendLine($"{TypeScriptConstants.ExportEnum} {GetTypeScriptName(typeToWrite)} {{");
        var fields = typeToWrite.GetFields(BindingFlags.Static | BindingFlags.Public);
        foreach (var field in fields)
        {
            sb.AppendDebugLine($"Default field name [{field.Name}]");
            var attributes = field.GetCustomAttributes().ToList();
            var result = ProcessMemberAttributes(attributes, field.Name, typeToWrite, sb);

            if (result.IsBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{field.Name}] is blocked");
                continue;
            }

            sb.AppendLine($"  {field.Name} = '{result.Name}',");
        }

        sb.AppendLine('}');
        return sb;
    }

    private StringBuilderCustom BuildFromClass(Type typeToWrite, StringBuilderCustom sb)
    {
        var affected = ListAffectedTypes(typeToWrite).ToList();
        var genericParameters = typeToWrite.IsGenericType ? typeToWrite.GetGenericArguments() : [];
        var genericHeader = genericParameters.Length == 0
            ? string.Empty
            : $"{TypeScriptConstants.GenericOpen}{string.Join(",", genericParameters.Select(x => x.Name))}{TypeScriptConstants.GenericClose}";
        var importsAdded = false;
        foreach (var affType in affected)
        {
            if (affType == typeToWrite)
            {
                continue;
            }

            sb.AppendLine(string.Format(TypeScriptConstants.ImportFormat, NormalizeClassName(GetTypeScriptName(affType))));
            importsAdded = true;
        }

        if (importsAdded)
        {
            sb.AppendLine();
        }

        sb.AppendLine($"{TypeScriptConstants.ExportInterface} {NormalizeClassName(GetTypeScriptName(typeToWrite))}{genericHeader} {{");

        var properties = typeToWrite.GetProperties();

        foreach (var property in properties)
        {
            var defaultName = GetClassPropertyNameToWrite(property.Name);
            sb.AppendDebugLine($"Default field name [{defaultName}]");
            var attributes = property.GetCustomAttributes().ToList();
            var result = ProcessMemberAttributes(attributes, defaultName, typeToWrite, sb, throwOnNullName: true);

            if (result.IsBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{property.Name}] is blocked");
                continue;
            }

            var isNullableByDefinition = IsNullableHelper.IsNullable(typeToWrite, property);
            if (isNullableByDefinition)
            {
                sb.AppendDebugLine("Property is nullable by definition");
            }

            var hasNotNullableAttribute = CommonHelper.HasNonNullableAttribute(property);
            if (hasNotNullableAttribute)
            {
                sb.AppendDebugLine("Property has non-nullable attribute");
            }

            var isNullable = isNullableByDefinition && !hasNotNullableAttribute;
            var context = new PropertyTypeExtractionContext
            {
                ClassToWrite = typeToWrite,
                PropInfo = property,
                PropertyType = property.PropertyType,
                AffectedTypes = affected,
                GenericTypes = genericParameters,
                SuppressNullable = hasNotNullableAttribute,
                BooleanContainer = null,
                IsNullable = isNullable
            };
            sb.AppendLine($"  {result.Name}{(isNullable ? "?" : string.Empty)}: {ResolveTypeToTypeScript(context)};");
        }

        sb.AppendLine('}');
        return sb;
    }

    private string GetTypeScriptName(Type type) => (parameters.UseFullNames ? type.FullName ?? type.Name : type.Name).Replace('.', '_');

    private string? TryResolveCustomMappedType(Type propertyType)
    {
        if (parameters.CustomMap.TryGetValue(propertyType.Name, out var value))
        {
            return value;
        }

        if (!string.IsNullOrWhiteSpace(propertyType.FullName) &&
            parameters.CustomMap.TryGetValue(propertyType.FullName, out var fullNameValue))
        {
            return fullNameValue;
        }

        return null;
    }

    private string? TryResolvePrimitiveType(Type propertyType)
    {
        if (NumberTypes.Contains(propertyType))
        {
            return TypeScriptConstants.NumberType;
        }

        if (propertyType == typeof(bool))
        {
            return TypeScriptConstants.BooleanType;
        }

        if (propertyType == typeof(string))
        {
            return TypeScriptConstants.StringType;
        }

        if (ToStringTypes.Contains(propertyType))
        {
            return TypeScriptConstants.StringType;
        }

        return null;
    }

    private bool GetNullabilityForGenericArg(Type argType, BooleanContainer nullableList)
    {
        return argType.IsValueType
            ? IsNullableHelper.IsValueTypeNullable(argType)
            : nullableList.GetValueAndMoveNext();
    }

    private string? TryResolveArrayType(PropertyTypeExtractionContext context, Type propertyType, BooleanContainer nullableList, bool nullable)
    {
        if (!propertyType.IsArray)
        {
            return null;
        }

        var elementContext = context.CreateDerived(propertyType.GetElementType()!, nullableList, nullable);
        return ResolveTypeToTypeScript(elementContext) + TypeScriptConstants.ArraySuffix;
    }

    private string? TryResolveDictionaryType(PropertyTypeExtractionContext context, Type propertyType, BooleanContainer nullableList)
    {
        if (!propertyType.InstanceOfGenericInterface(typeof(IDictionary<,>)))
        {
            return null;
        }

        var genericArguments = propertyType.GetInterfaces()
            .SingleOrDefault(x => x.InstanceOfGenericInterface(typeof(IDictionary<,>)))
            ?.GetGenericArguments() ?? propertyType.GetGenericArguments();

        var keyContext = context.CreateDerived(
            genericArguments[0],
            nullableList,
            GetNullabilityForGenericArg(genericArguments[0], nullableList));

        var valueContext = context.CreateDerived(
            genericArguments[1],
            nullableList,
            GetNullabilityForGenericArg(genericArguments[1], nullableList));

        return $"{TypeScriptConstants.MapType}{TypeScriptConstants.GenericOpen}{ResolveTypeToTypeScript(keyContext)}{TypeScriptConstants.GenericSeparator}{ResolveTypeToTypeScript(valueContext)}{TypeScriptConstants.GenericClose}";
    }

    private string? TryResolveEnumerableType(PropertyTypeExtractionContext context, Type propertyType, BooleanContainer nullableList)
    {
        if (!propertyType.InstanceOfGenericInterface(typeof(IEnumerable<>)))
        {
            return null;
        }

        var genericArguments = propertyType.GetGenericArguments();
        var elementContext = context.CreateDerived(
            genericArguments[0],
            nullableList,
            GetNullabilityForGenericArg(genericArguments[0], nullableList));

        return $"{ResolveTypeToTypeScript(elementContext)}{TypeScriptConstants.ArraySuffix}";
    }

    private string? TryResolveGenericType(PropertyTypeExtractionContext context, Type propertyType, BooleanContainer nullableList)
    {
        if (!propertyType.IsGenericType)
        {
            return null;
        }

        var localGenericArguments = propertyType.GetGenericArguments()
            .Take(GenericHelper.LocalGenericParameterCount(propertyType))
            .ToArray();

        var typeArgs = localGenericArguments
            .Select(arg => ResolveTypeToTypeScript(
                context.CreateDerived(arg, nullableList, GetNullabilityForGenericArg(arg, nullableList))))
            .Aggregate((a, b) => a + TypeScriptConstants.GenericSeparator + b);

        return $"{NormalizeClassName(GetTypeScriptName(propertyType))}{TypeScriptConstants.GenericOpen}{typeArgs}{TypeScriptConstants.GenericClose}";
    }

    private string ResolveTypeToTypeScript(PropertyTypeExtractionContext context)
    {
        var nullable = ResolveNullability(context);
        var propertyType = UnwrapNullableType(context.PropertyType);

        // Try simple type resolution (custom, primitive, enum, object)
        if (TryResolveSimpleType(propertyType, nullable) is { } simpleResult)
        {
            return simpleResult;
        }

        // Complex types require nullable tracking for generic arguments
        return ResolveComplexType(context, propertyType, nullable);
    }

    private bool ResolveNullability(PropertyTypeExtractionContext context)
    {
        if (context.SuppressNullable)
        {
            return false;
        }

        return context.PropInfo != null
            ? IsNullableHelper.IsNullable(context.ClassToWrite, context.PropInfo)
            : context.IsNullable;
    }

    private static Type UnwrapNullableType(Type type) =>
        Nullable.GetUnderlyingType(type) ?? type;

    private string? TryResolveSimpleType(Type propertyType, bool nullable)
    {
        // Custom mapped types
        if (TryResolveCustomMappedType(propertyType) is { } customType)
        {
            return CommonHelper.GetPropertyTypeWithNullable(customType, nullable);
        }

        // Primitive types (number, boolean, string)
        if (TryResolvePrimitiveType(propertyType) is { } primitiveType)
        {
            return CommonHelper.GetPropertyTypeWithNullable(primitiveType, nullable);
        }

        // Enum types
        if (propertyType.IsEnum)
        {
            return CommonHelper.GetPropertyTypeWithNullable(GetTypeScriptName(propertyType), nullable);
        }

        // Object type
        if (propertyType == typeof(object))
        {
            return TypeScriptConstants.UnknownType;
        }

        return null;
    }

    private string ResolveComplexType(PropertyTypeExtractionContext context, Type propertyType, bool nullable)
    {
        var nullableList = GetNullableContainer(context);

        // Array types
        if (TryResolveArrayType(context, propertyType, nullableList, nullable) is { } arrayType)
        {
            return CommonHelper.GetPropertyTypeWithNullable(arrayType, nullable);
        }

        // Dictionary types (must check before IEnumerable since dictionaries implement IEnumerable)
        if (TryResolveDictionaryType(context, propertyType, nullableList) is { } dictType)
        {
            return CommonHelper.GetPropertyTypeWithNullable(dictType, nullable);
        }

        // Enumerable types
        if (TryResolveEnumerableType(context, propertyType, nullableList) is { } enumerableType)
        {
            return CommonHelper.GetPropertyTypeWithNullable(enumerableType, nullable);
        }

        // Generic types
        if (TryResolveGenericType(context, propertyType, nullableList) is { } genericType)
        {
            return CommonHelper.GetPropertyTypeWithNullable(genericType, nullable);
        }

        // Affected types (types that need imports)
        if (IsAffectedOrGenericType(context, propertyType))
        {
            return CommonHelper.GetPropertyTypeWithNullable(NormalizeClassName(GetTypeScriptName(propertyType)), nullable);
        }

        throw new UnsupportedTypeException(propertyType);
    }

    private BooleanContainer GetNullableContainer(PropertyTypeExtractionContext context) =>
        (context.PropInfo == null
            ? context.BooleanContainer
            : IsNullableHelper.IsNullableContainer(context.ClassToWrite, context.PropInfo))
        ?? throw new InvalidOperationException(
            $"BooleanContainer should not be null for complex property type. Property: {context.PropInfo?.Name}, Type: {context.PropertyType}");

    private static bool IsAffectedOrGenericType(PropertyTypeExtractionContext context, Type propertyType) =>
        context.AffectedTypes.Any(x => x.FullName == propertyType.FullName) ||
        context.GenericTypes.Any(x => x.Name == propertyType.Name);
    internal List<Type> ListAffectedTypes(Type type)
    {
        var affected = new List<Type>();
        if (type.IsGenericType)
        {
            AddType(affected, type.GenericTypeArguments);
        }

        var props = type.GetProperties();
        foreach (var prop in props)
        {
            if (prop.PropertyType.IsGenericType)
            {
                AddType(affected, prop.PropertyType.GenericTypeArguments);
            }

            AddType(affected, [prop.PropertyType]);
        }

        RemoveTypes(affected);
        return affected;
    }

    private void AddType(List<Type> list, Type[] types)
    {
        foreach (var type in types)
        {
            if (HasCustomMapping(type))
            {
                continue;
            }

            if (type.IsGenericType)
            {
                AddType(list, type.GenericTypeArguments);
            }

            if (type.IsArray)
            {
                AddType(list, [type.GetElementType()!]);
            }
            else if (ShouldIncludeType(type, list))
            {
                list.Add(type);
            }
        }
    }

    private bool ShouldIncludeType(Type type, List<Type> existingTypes)
    {
        if (type.Namespace == null)
        {
            return false;
        }

        if (!IncludedType(type.Namespace))
        {
            return false;
        }

        if (type.GUID == Guid.Empty)
        {
            return false;
        }

        return !TypeAlreadyExists(type, existingTypes);
    }

    private bool TypeAlreadyExists(Type type, List<Type> existingTypes) =>
        existingTypes.Any(existing => TypeNamesMatch(existing, type));

    private bool TypeNamesMatch(Type a, Type b) =>
        NormalizeClassName(a.FullName ?? a.Name) == NormalizeClassName(b.FullName ?? b.Name);

    private bool HasCustomMapping(Type type) =>
        parameters.CustomMap.ContainsKey(type.Name) ||
        (!string.IsNullOrWhiteSpace(type.FullName) && parameters.CustomMap.ContainsKey(type.FullName));

    private List<Type> GetTypes()
    {
        var types = new List<Type>();
        var filePaths = parameters.LibraryFileNames.Select(x => Path.GetDirectoryName(Path.GetFullPath(x))).ToList();
        foreach (var param in parameters.LibraryFileNames)
        {
            var exactPath = Path.GetFullPath(param);
            var context = new CustomAssemblyLoadContext(filePaths);
            var assembly = context.LoadAssembly(exactPath);
            types.AddRange(assembly.GetExportedTypes().Where(IsExportableType));
        }

        return types;
    }

    private bool IsExportableType(Type type) =>
        IncludedType(type.FullName) &&
        !IsCompilerGeneratedType(type) &&
        !ExcludedType(type.FullName);

    private static bool IsCompilerGeneratedType(Type type) =>
        type.Name.StartsWith(TypeScriptConstants.CompilerGeneratedTypeIndicator);

    private int RemoveTypes(List<Type> types) => types.RemoveAll(ShouldFilterType);

    private bool ShouldFilterType(Type type) =>
        HasCustomMapping(type) ||
        IsInExcludedNamespace(type) ||
        IsCollectionType(type);

    private bool IsInExcludedNamespace(Type type) =>
        !string.IsNullOrWhiteSpace(type.FullName) &&
        parameters.RootNamespacesExcluded.Any(excluded => type.FullName.Contains(excluded));

    private static bool IsCollectionType(Type type)
    {
        var interfaces = type.GetInterfaces();
        return interfaces.Any(i => i.InstanceOfGenericType(typeof(IDictionary<,>))) ||
               interfaces.Any(i => i.InstanceOfGenericType(typeof(IEnumerable<>)));
    }

    private string GetClassPropertyNameToWrite(string s) => parameters.CamelCaseProperties ? char.ToLowerInvariant(s[0]) + s[1..] : s;

    private bool IncludedType(string needle) => parameters.RootNamespaces.Any(needle.StartsWith);

    private bool ExcludedType(string needle) => parameters.RootNamespacesExcluded.Count != 0 &&
                                                parameters.RootNamespacesExcluded.Any(needle.StartsWith);

}