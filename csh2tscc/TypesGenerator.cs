using System.Data;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text.Json.Serialization;

namespace csh2tscc;

public class TypesGenerator(TypesGeneratorParameters parameters)
{
    public static TypesGenerator Create(TypesGeneratorParameters parameters) => new(parameters);

    private static readonly Type[] NumberTypes = [
        typeof(int), typeof(uint), typeof(short), typeof(byte), typeof(sbyte), typeof(long), typeof(ulong),
        typeof(float), typeof(double), typeof(ushort), typeof(decimal)
    ];


    private static readonly Type[] ToStringTypes = [
        typeof(Guid), typeof(DateTime), typeof(Uri), typeof(TimeSpan)
    ];
    public TypesGeneratorParameters Config => parameters;

    public Dictionary<string, string> TransformTypes() => GetTypes().ToDictionary(typeToWrite => NormalizeClassName(GetTypeName(typeToWrite)) + ".tsx", BuildFileFromType);

    private static string NormalizeClassName(string argName) => argName.Contains('`') ? argName[..argName.LastIndexOf('`')] : argName;

    internal string BuildFileFromType(Type typeToWrite)
    {
        var sb = new StringBuilderCustom(parameters.Verbose);
        sb.AppendDebugLine("Debug mode");
        sb.AppendLine("//This file is AUTOGENERATED!!! All manual changes will be lost after regeneration.");
        sb.AppendLine();
        return typeToWrite.IsEnum ? BuildFromEnum(typeToWrite, sb) : BuildFromClass(typeToWrite, sb);
    }

    private string BuildFromEnum(Type typeToWrite, StringBuilderCustom sb)
    {
        sb.AppendLine($"export enum {GetTypeName(typeToWrite)} {{");
        var fields = typeToWrite.GetFields(BindingFlags.Static | BindingFlags.Public);
        foreach (var field in fields)
        {
            var value = field.Name;
            sb.AppendDebugLine($"Default field name [{value}]");
            var attributes = field.GetCustomAttributes().ToList();
            var nameAttributeCount = 0;
            var isBlocked = false;
            foreach (var attribute in attributes)
            {
                var attributeType = attribute.GetType();
                var attributeFromNamingDictionaryExists = parameters.SerializationNamingAttributes.TryGetValue(attributeType.Name, out var attributeNameFromNamingDictionary);
                if (attributeFromNamingDictionaryExists)
                {
                    ++nameAttributeCount;
                    var prop = attributeType.GetProperty(attributeNameFromNamingDictionary) ?? throw new InvalidDataContractException($"No property name [{attributeNameFromNamingDictionary}] for type [{attributeType.Name}]");
                    value = prop.GetValue(attribute, null)?.ToString();
                    sb.AppendDebugLine($"New field name is [{value}] from attribute [{attributeNameFromNamingDictionary}]");
                }

                var attributeFromNoSerializingList = parameters.NoSerializationAttributes.SingleOrDefault(x => x == attributeType.Name);
                switch (attributeFromNoSerializingList)
                {
                    case null:
                        continue;
                    case nameof(JsonIgnoreAttribute)
                        when (attribute.GetType().FullName?.StartsWith("System.Text.Json") ?? false):
                        {
                            var jic = (JsonIgnoreCondition)attribute.GetType().GetProperty("Condition").GetValue(attribute, null);
                            sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}] condition is [{jic}]");
                            if (jic == JsonIgnoreCondition.Always)
                            {
                                isBlocked = true;
                            }

                            break;
                        }
                    default:
                        sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}]");
                        isBlocked = true;
                        break;
                }
            }

            if (nameAttributeCount > 1)
            {
                throw new InvalidDataException($"Property name [{value}] of type [{typeToWrite}] has more than one serialization naming attribute");
            }

            if (isBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{field.Name}] is blocked");
                continue;
            }

            sb.AppendLine($"  {field.Name} = '{value}',");
        }

        sb.Append('}');
        return sb.ToString();
    }

    private string BuildFromClass(Type typeToWrite, StringBuilderCustom sb)
    {
        var affected = ListAffectedTypes(typeToWrite).ToList();
        var genericParameters = typeToWrite.IsGenericType ? typeToWrite.GetGenericArguments() : [];
        var genericHeader = genericParameters.Length == 0 ? string.Empty : "<" + string.Join(",", genericParameters.Select(x => x.Name)) + ">";
        var importsAdded = false;
        foreach (var affType in affected)
        {
            if (affType == typeToWrite)
            {
                continue;
            }

            sb.AppendLine($"import {{ {NormalizeClassName(GetTypeName(affType))} }} from \"./{NormalizeClassName(GetTypeName(affType))}\";");
            importsAdded = true;
        }

        if (importsAdded)
        {
            sb.AppendLine();
        }

        sb.AppendLine($"export interface {NormalizeClassName(GetTypeName(typeToWrite))}{genericHeader} {{");

        var properties = typeToWrite.GetProperties();

        foreach (var property in properties)
        {
            var value = GetClassPropertyNameToWrite(property.Name);
            sb.AppendDebugLine($"Default field name [{value}]");
            var attributes = property.GetCustomAttributes().ToList();
            var nameAttributeCount = 0;
            var isBlocked = false;
            foreach (var attribute in attributes)
            {
                var attributeType = attribute.GetType();
                var attributeFromNamingDictionaryExists = parameters.SerializationNamingAttributes.TryGetValue(attributeType.Name, out var attributeNameFromNamingDictionary);
                if (attributeFromNamingDictionaryExists)
                {
                    ++nameAttributeCount;
                    var prop = attributeType.GetProperty(attributeNameFromNamingDictionary) ?? throw new InvalidDataContractException($"No property name [{attributeNameFromNamingDictionary}] for type [{attributeType.Name}]");
                    value = prop.GetValue(attribute, null)?.ToString() ?? throw new InvalidDataContractException($"Property name [{attributeNameFromNamingDictionary}] for type [{attributeType.Name}] is null");
                    sb.AppendDebugLine($"New field name is [{value}] from attribute [{attributeNameFromNamingDictionary}]");
                }

                var attributeFromNoSerializingList = parameters.NoSerializationAttributes.SingleOrDefault(x => x == attributeType.Name);
                switch (attributeFromNoSerializingList)
                {
                    case null:
                        continue;
                    case nameof(JsonIgnoreAttribute):
                        {
                            var jic = (JsonIgnoreCondition)attribute.GetType().GetProperty("Condition").GetValue(attribute, null);
                            sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}] condition is [{jic}]");
                            if (jic == JsonIgnoreCondition.Always)
                            {
                                isBlocked = true;
                            }

                            break;
                        }
                    default:
                        isBlocked = true;
                        sb.AppendDebugLine($"Found attribute [{attribute.GetType().Name}]");
                        break;
                }
            }

            if (nameAttributeCount > 1)
            {
                throw new InvalidDataException($"Property name [{value}] of type [{typeToWrite}] has more than one serialization naming attribute");
            }

            if (isBlocked)
            {
                sb.AppendDebugLine($"Serialization of the property [{property.Name}] is blocked");
                continue;
            }

            var isNullableByDefinition = IsNullableHelper.IsNullable(typeToWrite, property);
            if (isNullableByDefinition)
            {
                sb.AppendDebugLine("Property is nullable by definition");
            }

            var hasNotNullableAttribute = CommonHelper.HasNonNullableAttribute(property);
            if (hasNotNullableAttribute)
            {
                sb.AppendDebugLine("Property has non-nullable attribute");
            }

            var isNullable = isNullableByDefinition && !hasNotNullableAttribute;
            var context = new PropertyTypeExtractionContext
            {
                ClassToWrite = typeToWrite,
                PropInfo = property,
                PropertyType = property.PropertyType,
                AffectedTypes = affected,
                GenericTypes = genericParameters,
                SuppressNullable = hasNotNullableAttribute,
                BooleanContainer = null,
                IsNullable = isNullable
            };
            sb.AppendLine($"  {value}{(isNullable ? "?" : string.Empty)}: {GetPropertyTypeTypescript(context)};");
        }

        sb.Append('}');
        return sb.ToString();
    }

    private string GetTypeName(Type type) => (parameters.UseFullNames ? type.FullName ?? type.Name : type.Name).Replace('.', '_');
    private string GetPropertyTypeTypescript(PropertyTypeExtractionContext context)
    {
        var nullable = context.PropInfo != null ? IsNullableHelper.IsNullable(context.ClassToWrite, context.PropInfo) : context.IsNullable;
        if (context.SuppressNullable)
        {
            nullable = false;
        }

        var propertyType = context.PropertyType;
        var checkedType = Nullable.GetUnderlyingType(propertyType);
        if (checkedType != null)
        {
            propertyType = checkedType;
        }

        if (parameters.CustomMap.TryGetValue(propertyType.Name, out var value))
        {
            return CommonHelper.GetPropertyTypeWithNullable(value, nullable);
        }

        if (!string.IsNullOrWhiteSpace(propertyType.FullName) &&
            parameters.CustomMap.TryGetValue(propertyType.FullName, out var value1))
        {
            return CommonHelper.GetPropertyTypeWithNullable(value1, nullable);
        }

        if (NumberTypes.Contains(propertyType))
        {
            return CommonHelper.GetPropertyTypeWithNullable("number", nullable);
        }

        if (propertyType == typeof(bool))
        {
            return CommonHelper.GetPropertyTypeWithNullable("boolean", nullable);
        }

        if (propertyType.IsEnum)
        {
            return CommonHelper.GetPropertyTypeWithNullable(GetTypeName(propertyType), nullable);
        }

        if (propertyType == typeof(string))
        {
            return CommonHelper.GetPropertyTypeWithNullable("string", nullable);
        }

        if (propertyType == typeof(object))
        {
            return "unknown";
        }

        var nullableList = (context.PropInfo == null ? context.BooleanContainer : IsNullableHelper.IsNullableContainer(context.ClassToWrite, context.PropInfo)) ?? throw new Exception("Should not happen");
        if (propertyType.IsArray)
        {
            return CommonHelper.GetPropertyTypeWithNullable(GetPropertyTypeTypescript(context.CreateDerived(propertyType.GetElementType()!, nullableList, nullable)) + "[]", nullable);
        }

        if (propertyType.InstanceOfGenericInterface(typeof(IDictionary<,>)))
        {
            var genericArguments = propertyType.GetInterfaces().SingleOrDefault(x => x.InstanceOfGenericInterface(typeof(IDictionary<,>)))?.GetGenericArguments() ?? propertyType.GetGenericArguments();
            var key = context.CreateDerived(genericArguments[0],
                    nullableList,
                    genericArguments[0].IsValueType
                ? IsNullableHelper.IsValueTypeNullable(genericArguments[0])
                : nullableList.GetValueAndMoveNext());
            var val = context.CreateDerived(genericArguments[1],
                nullableList,
                genericArguments[1].IsValueType
                    ? IsNullableHelper.IsValueTypeNullable(genericArguments[1])
                    : nullableList.GetValueAndMoveNext());
            return CommonHelper.GetPropertyTypeWithNullable($"Map<{GetPropertyTypeTypescript(key)}, {GetPropertyTypeTypescript(val)}>", nullable);
        }

        if (propertyType.InstanceOfGenericInterface(typeof(IEnumerable<>)))
        {
            var genericArguments = propertyType.GetGenericArguments();
            var element = context.CreateDerived(genericArguments[0],
                nullableList,
                genericArguments[0].IsValueType
                ? IsNullableHelper.IsValueTypeNullable(genericArguments[0])
                : nullableList.GetValueAndMoveNext());
            return CommonHelper.GetPropertyTypeWithNullable($"{GetPropertyTypeTypescript(element)}[]", nullable);
        }

        if (ToStringTypes.Contains(propertyType))
        {
            return CommonHelper.GetPropertyTypeWithNullable("string", nullable);
        }

        if (propertyType.IsGenericType)
        {
            var localGenericArguments = propertyType.GetGenericArguments().Take(GenericHelper.LocalGenericParameterCount(propertyType)).ToArray();
            var typeDefinition = NormalizeClassName(GetTypeName(propertyType)) + "<" + localGenericArguments
                .Select((x, j) => GetPropertyTypeTypescript(context.CreateDerived(x, nullableList, x.IsValueType
                    ? IsNullableHelper.IsValueTypeNullable(x)
                    : nullableList.GetValueAndMoveNext()))).Aggregate((i, j) => i + ", " + j) + ">";

            return CommonHelper.GetPropertyTypeWithNullable(typeDefinition, nullable);
        }

        if (context.AffectedTypes.Any(x => x.FullName == propertyType.FullName) || context.GenericTypes.Any(x => x.Name == propertyType.Name))
        {
            return CommonHelper.GetPropertyTypeWithNullable(NormalizeClassName(GetTypeName(propertyType)), nullable);
        }

        throw new InvalidExpressionException($"Unsupported type [{propertyType.FullName}]");
    }
    internal List<Type> ListAffectedTypes(Type type)
    {
        var affected = new List<Type>();
        if (type.IsGenericType)
        {
            AddType(affected, type.GenericTypeArguments);
        }

        var props = type.GetProperties();
        foreach (var prop in props)
        {
            if (prop.PropertyType.IsGenericType)
            {
                AddType(affected, prop.PropertyType.GenericTypeArguments);
            }

            AddType(affected, [prop.PropertyType]);
        }

        RemoveTypes(affected);
        return affected;
    }

    private void AddType(List<Type> list, Type[] types)
    {
        foreach (var type in types)
        {
            if (parameters.CustomMap.ContainsKey(type.Name) || (!string.IsNullOrWhiteSpace(type.FullName) && parameters.CustomMap.ContainsKey(type.FullName)))
            {
                continue;
            }

            if (type.IsGenericType)
            {
                AddType(list, type.GenericTypeArguments);
            }

            if (type.IsArray)
            {
                AddType(list, [type.GetElementType()!]);
            }
            else if (type.Namespace != null && IncludedType(type.Namespace) && type.GUID != Guid.Empty && list.All(x => NormalizeClassName(x.FullName ?? x.Name) != NormalizeClassName(type.FullName ?? type.Name)))
            {
                list.Add(type);
            }
        }
    }

    private List<Type> GetTypes()
    {
        var types = new List<Type>();
        var filePaths = parameters.LibraryFileNames.Select(x => Path.GetDirectoryName(Path.GetFullPath(x))).ToList();
        foreach (var param in parameters.LibraryFileNames)
        {
            var exactPath = Path.GetFullPath(param);
            var context = new CustomAssemblyLoadContext(filePaths);
            var assembly = context.LoadAssembly(exactPath);
            types.AddRange(assembly.GetExportedTypes().Where(t => IncludedType(t.FullName) && !t.Name.StartsWith('<') && !ExcludedType(t.FullName)));
        }

        return types;
    }

    private int RemoveTypes(List<Type> types)
    {
        var result = 0;
        result += types.RemoveAll(t => parameters.CustomMap.ContainsKey(t.Name));
        result += types.RemoveAll(t => !string.IsNullOrWhiteSpace(t.FullName) && parameters.CustomMap.ContainsKey(t.FullName));
        result += types.RemoveAll(t => !string.IsNullOrWhiteSpace(t.FullName) && parameters.RootNamespacesExcluded.Any(x => t.FullName.Contains(x)));
        result += types.RemoveAll(t => t.GetInterfaces().Any(i => i.InstanceOfGenericType(typeof(IDictionary<,>))));
        result += types.RemoveAll(t => t.GetInterfaces().Any(i => i.InstanceOfGenericType(typeof(IEnumerable<>))));
        return result;
    }

    private string GetClassPropertyNameToWrite(string s) => parameters.CamelCaseProperties ? char.ToLowerInvariant(s[0]) + s[1..] : s;

    private bool IncludedType(string needle) => parameters.RootNamespaces.Any(needle.StartsWith);

    private bool ExcludedType(string needle) => parameters.RootNamespacesExcluded.Count != 0 &&
                                                parameters.RootNamespacesExcluded.Any(needle.StartsWith);

}